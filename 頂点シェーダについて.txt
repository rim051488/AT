頂点シェーダの話
頂点情報(1点における情報量→構造体)
一般的な基本頂点では…
①座標
②法線
③UV
④頂点カラー

DxLibでは
①座標
②法線
③UV
④UV2
⑤ディフューズ
⑥スペキュラ
//法線マップありだと
⑦接線ベクトル(Tangent)
⑧従法線ベクトル(Binormal)
//②⑦⑧で物体表面に直交座標系を作るため
//スキニングするなら
⑨ボーン№[0]
⑩ウェイト[0]
⑪ボーン№[1]
⑫ウェイト[1]
//もしスキンメッシュアニメーション(ボーンで変形するやつ)
//をするのなら、かならず2つ以上のボーンの番号とウェイトの
//情報が入ってくる
//DxLibの場合最大４ボーンから影響を受ける
⑬ボーン№[2]
⑭ウェイト[2]
⑮ボーン№[3]
⑯ウェイト[3]

//自分で頂点を作る場合
DrawPrimitiveShader3Dとかで頂点集めて使う場合は
VERTEX3DShader構造体に従う。

MV1系列は、上記のように数がわからないので
MV1GetTriangleListVertexType()
で種別を取得して、それによって、頂点シェーダ入力を変える。

メッシュ≠トライアングルリスト
メッシュ＝複数のトライアングルリスト

トライアングルリスト＝三角形の集合体
なぜかグループ分けされてる

もしかしたら、このトライアングルリストごとに、頂点タイプが違うかも
しれない。

頂点タイプをMV1GetTriangleListVertexType()で取得するのですが


3Dの座標情報をそのまま2Dの座標情報として与えてもうまくいかない

3D→2D
この変換をプロジェクション変換といいます。
	もしくはパースペクティブといいます。
これは、中身は行列です(ちょっとややこしい)
PerspectiveFovLH
的な関数で作られます。

で、DxLibの場合は、定数バッファの中に
あらかじめ入ってます。




シェーダにおける座標にはPOSITIONと
SV_POSITIONがあります。明確に違うので
注意しましょう。

SVはSystemValueの意味らしいです。
ラスタライザに渡すという意味で、システム
用ということでこのSVをつけてる。

補間のされかたが通常のPOSITIONとは違うので
注意しましょう。もしピクセルシェーダで
色として使いたい場合はSVではないほうを
使いましょう。SVとそうでない２つを渡す
必要が出てくる。

DxLibでは、バイト数をケチって
matrixを4x3で表現することがあります。

本来、座標変換に使用する行列は
以下のような4x4の形です。
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
ところが、通常の移動や回転、カメラなどは
上３つしか使いません。
回転と拡縮は、左上3x3しか使いません。
平行移動がなけれあば3x3で十分。
ところが平行移動が必要なため４列目が
必要になった。
R R R Tx
R R R Ty
R R R Tz
0 0 0 1
で、平行移動を付け加えても４行目は
不要というか、0001固定なのがわかりますね？
なので、DxLibでは４行目を省略しています。

行列には行優先と列優先というのがある
行列の乗算の順番のことです。

数学的には行列は左に左にかけていく。
|1 0||x|
|0 1||y|
これを「列優先」という
DxLibでは行優先を採用しており
|x y||1 0|
     |0 1|
のように右に右にかけていく。

hlslは数学的になってます。つまり、列優先。


|a b||e f|=|ae+bg af+bh|
|c d||g h| |ce+dg cf+dh|


dxc.exeとfxc.exeがある。
DxLibで使われてるのがfxc.exeですが、VisualStudioの
デフォルトコンパイラがdxc.exeです。

どうもDxLibの頂点シェーダにおいてはdxc.exeが
うまく作用せず、まともな結果にならない。
このため、怪しいと思ったらfxc.exeでコンパイルしてみましょう。


