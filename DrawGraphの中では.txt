どうやって画面上にものを表示してるのか
この流れを「レンダリングパイプライン」
といいます。
シェーダを書く、高速化する等にはこの
パイプラインのイメージor理解が必要になります。

例えばDrawGraphをするときに何が行われているのか
を理解する。

あほコード
毎フレームロードしてた。

DxLibでは描画のプロセスが隠蔽されて簡略化されている。

DrawGraph時(dxdiagでハードの情報が見れる)
前提条件：グラボにない情報は「表示」されない
①４つの頂点の情報をグラボ(VRAM)に転送する
②テクスチャをまずメモリ(RAM)上にロードする
(pngやjpgなどの既圧縮テクスチャはこの時点で展開される)
αありの画像の場合、RGBAなので32bit=4byteこれが100x100の
場合、10000*4≒40KB。これがpngだと4KBくらいになったりします。
なので、pngやjpgを使ってる場合、ストレージ上の
サイズは実はあてにならない。
VRAMまで圧縮状態で転送されるフォーマットもある。
DXTC,BC, ETC,PVRTC,AXTCなどがある←きれいじゃない
③RAM上のメモリをVRAMに転送する。
④頂点の座標変換を行う(100,100ではない→100/640,100/480)VS
	(画面自体が-1～1に正規化されてるため)
⑤三角形をピクセル化する(ラスタライズ)→PSが呼ばれる
(グラボの役割として、三角形をピクセル化するというのがある)
⑥PS上でVRAM上のテクスチャを参照して、頂点から得たUV値を
	もとにテクスチャの特定のピクセルを取得し、その色で
	画面を塗りつぶす

なので、テクスチャが１つにまとまってる←高速化につながる
プログラムばかりが高速化ではない。例えばfree texture packerなどを
使うだけで、改善するのかもしれない。まとめたテクスチャのことを
texture atlas(テクスチャアトラス)という。

☆TextureAtlasを使うと当然LoadGraphの回数は減るし、DrawCallの回数も減る。
ただし、DrawGraph系をそのまま使っちゃうと強制的に4頂点1回描画になるので
この高速化には実はDrawGraph系は向いてない(あくまで初心者向け)
この場合はDrawPrimitive2Dなどを使用する。
サンプル的には、TrailRendererのTextureTrailRendererが参考になるだろう。